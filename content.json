{"meta":{"title":"子书苍珏","subtitle":"一蓑烟雨任平生","description":"硬件","author":"子书苍珏","url":"https://hp-l.gitee.io","root":"/"},"pages":[{"title":"","date":"2021-11-05T14:56:13.719Z","updated":"2021-11-05T14:56:13.719Z","comments":true,"path":"about/index.html","permalink":"https://hp-l.gitee.io/about/index.html","excerpt":"","text":"Hello😜 一个用JS开发的硬件工程师 😋 雷达图看不到刷新刷新就好啦 var ctx = document.getElementById('chart2945').getContext('2d'); var options = { type: 'radar', data: { labels: ['C', 'Python', 'HTML', 'micropython', 'ESP8266', 'ESP32', 'STM32', 'SCT15', '微信小程序'], datasets: [{ label: '值', backgroundColor: '#9400D377', borderColor: '#9400D3', data: [20, 50, 40, 80, 40, 80, 55, 55, 10], lineTension: 0.2, pointStyle: 'rectRounded', pointHoverBackgroundColor: '#FFFFFF' }] }, options: { legend: { labels: { fontColor: '#9400D3', fontSize: 12, FontFamily: '' } }, layout: { padding: { left: 0, right: 0, top: 0, bottom: 0 } }, responsive: true, title: { display: true, text: 'My dataset' }, scale: { angleLines: { display: true }, ticks: { suggestedMin: 0, suggestedMax: 80 } } } }; new Chart(ctx, options);"},{"title":"","date":"2021-11-05T14:56:09.435Z","updated":"2021-11-05T14:56:09.435Z","comments":true,"path":"404/index.html","permalink":"https://hp-l.gitee.io/404/index.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"收藏夹","date":"2020-11-08T14:28:43.000Z","updated":"2021-11-05T14:56:14.034Z","comments":true,"path":"favorite/index.html","permalink":"https://hp-l.gitee.io/favorite/index.html","excerpt":"","text":""},{"title":"artitalk","date":"2021-02-05T06:10:56.000Z","updated":"2021-11-05T14:56:13.835Z","comments":true,"path":"artitalk/index.html","permalink":"https://hp-l.gitee.io/artitalk/index.html","excerpt":"","text":""},{"title":"三白说","date":"2021-11-05T14:56:13.893Z","updated":"2021-11-05T14:56:13.893Z","comments":true,"path":"bb/index.html","permalink":"https://hp-l.gitee.io/bb/index.html","excerpt":"","text":""},{"title":"友人帐","date":"2021-11-05T14:56:14.052Z","updated":"2021-11-05T14:56:14.052Z","comments":true,"path":"friends/index.html","permalink":"https://hp-l.gitee.io/friends/index.html","excerpt":"","text":"软件大佬 硬件大佬 三白的博客链接 链接：https://hp-l.gitee.io/头像：https://hp-l.gitee.io/img/%E5%8D%A1%E9%80%9A%E5%A4%B4%E5%83%8F.jpg描述：一蓑烟雨任平生标签：[C，micropython，PCB_layout，Termux，Linux，STM32]博客截图（若有）：https://hp-l.gitee.io/img/blog.png 需添加友链的朋友可以到Gitee提交issue 123456789&#123; &quot;title&quot;: &quot;&quot;, //标题 &quot;avatar&quot;: &quot;&quot;, //头像地址 &quot;screenshot&quot;: &quot;&quot;, //网页截图 &quot;url&quot;: &quot;&quot;, //网站地址 &quot;description&quot;: &quot;&quot;, //简介 &quot;group&quot;: &quot;&quot;, //分组：技术大佬、小伙伴 &quot;class&quot;: &quot;&quot; //软件大佬、硬件大佬，都不是可不填&#125;为了提高图片加载速度，建议优化图片尺寸：1.打开 压缩图 上传自己的头像，将图片尺寸调整到 96px 后下载。 2.将压缩后的图片上传到 去不图床 并使用此图片链接作为头像。 3.重复上述步骤，压缩网站截图并把尺寸调整到 540x360 以下。"},{"title":"项目","date":"2021-01-04T12:00:53.000Z","updated":"2021-11-05T14:56:21.982Z","comments":true,"path":"project/index.html","permalink":"https://hp-l.gitee.io/project/index.html","excerpt":"","text":"局域网微信小程序与ESP32物联网通讯小程序代码微信小程序代码Gitee仓库链接https://gitee.com/HP-L/esp32_-we-char_-connect"},{"title":"所有标签","date":"2021-11-05T14:56:21.992Z","updated":"2021-11-05T14:56:21.992Z","comments":true,"path":"tags/index.html","permalink":"https://hp-l.gitee.io/tags/index.html","excerpt":"","text":""},{"title":"工具","date":"2020-11-02T01:06:42.000Z","updated":"2021-11-05T14:56:22.003Z","comments":true,"path":"tools/index.html","permalink":"https://hp-l.gitee.io/tools/index.html","excerpt":"","text":""},{"title":"xml","date":"2020-11-02T00:32:23.000Z","updated":"2021-11-05T14:56:22.014Z","comments":true,"path":"xml/index.html","permalink":"https://hp-l.gitee.io/xml/index.html","excerpt":"","text":"若喜歡請關注 ^_^订阅请将以下代码输入RSS阅读器1https:&#x2F;&#x2F;hp-l.github.io&#x2F;atom.xml"},{"title":"Gallery","date":"2020-02-03T02:43:45.000Z","updated":"2021-11-05T14:56:21.873Z","comments":true,"path":"gallery/index.html","permalink":"https://hp-l.gitee.io/gallery/index.html","excerpt":"","text":"图片源于网络，侵删"}],"posts":[{"title":"树莓派安装Ubuntu21.10","slug":"树莓派安装Ubuntu21-10","date":"2021-11-05T17:59:24.000Z","updated":"2021-11-05T18:09:45.410Z","comments":true,"path":"2021/11/06/shu_mei_pai_an_zhuang_ubuntu21_10/shu_mei_pai_an_zhuang_ubuntu21_10/","link":"","permalink":"https://hp-l.gitee.io/2021/11/06/shu_mei_pai_an_zhuang_ubuntu21_10/shu_mei_pai_an_zhuang_ubuntu21_10/","excerpt":"","text":"树莓派安装 Ubuntu21.10下载、安装烧录工具Raspberry Pi Imager：link 烧录过程选择镜像点击CHOOSE OS，选择Other general purpose OS ，再选择 Ubuntu 找到与自己树莓派相应的版本，我的是 Raspberry 4，因此选择第一个 选择 SD 卡设备点击CHOOSE STORAGE ，选择自己的 SD 卡设备 点击WRITE 等待烧录完成，拔出 SD 卡，插入树莓派卡槽，插电源开机。至此为树莓派安装 Ubuntu 流程结束，插上显示器后效果如下","categories":[],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"https://hp-l.gitee.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://hp-l.gitee.io/tags/Ubuntu/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-11-05T14:56:10.229Z","updated":"2021-11-05T14:56:10.229Z","comments":true,"path":"2021/11/05/hello_world/hello_world/","link":"","permalink":"https://hp-l.gitee.io/2021/11/05/hello_world/hello_world/","excerpt":"","text":"Welcome to my Blog! Gitgit config命令预先配置好相关的用户信息12git config --global user.name &quot;你的名字或昵称&quot;git config --global user.email &quot;你的邮箱&quot; 三步走123git add . #将当前目录所有文件添加到git暂存区git commit -m &quot;my first commit&quot; #提交并备注提交信息git push origin master #将本地提交推送到远程仓库 Quick Start安装的插件网址转拼音插件安装1npm i hexo-permalink-pinyin --save 配置及使用在根目录中的_config.yml中国添加 1234# 网站 文字转拼音permalink_pinyin: enable: true separator: &quot;_&quot; # default: &#x27;-&#x27; hexo-electric-clock 电子时钟插件安装1npm i hexo-electric-clock --save 配置及使用不是主题的yml文件 12345678910111213141516171819202122232425262728electric_clock: priority: 5 enable: true enable_page: all layout: type: class name: sticky_layout index: 0 temple_html: &#x27; &lt;div class=&quot;card-widget card-clock&quot;&gt; &lt;!-- 挂载容器 --&gt; &lt;div class=&quot;card-glass&quot;&gt; &lt;div class=&quot;card-background&quot;&gt; &lt;div class=&quot;card-content&quot;&gt; &lt;div id=&quot;hexo_electric_clock&quot;&gt; &lt;img id=&quot;card-clock-loading&quot; src=&quot;https://cdn.jsdelivr.net/gh/Zfour/Butterfly-clock/clock/images/weather/loading.gif&quot; style=&quot;height: 120px; width: 100%;&quot; data-ll-status=&quot;loading&quot; class=&quot;entered loading&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&#x27; Chart动态图标插件安装1npm install hexo-tag-chart --save 配置及使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!--fontColor:数据颜色--&gt;&lt;!--padding:上下左右填充--&gt;&lt;!--suggestedMin:最小值--&gt;&#123;% p center logo large, Hello😜 %&#125;***&#123;% p center h1, 一个用JS开发的硬件工程师 😋 %&#125;&#123;% p center small, 雷达图看不到刷新刷新就好啦 %&#125;&#123;% chart 100% 300 %&#125;&#123; type: &#x27;radar&#x27;, data: &#123; labels: [&#x27;C&#x27;, &#x27;Python&#x27;, &#x27;HTML&#x27;, &#x27;micropython&#x27;, &#x27;ESP8266&#x27;, &#x27;ESP32&#x27;, &#x27;STM32&#x27;, &#x27;SCT15&#x27;, &#x27;微信小程序&#x27;], datasets: [&#123; label: &#x27;值&#x27;, backgroundColor: &#x27;#9400D377&#x27;, borderColor: &#x27;#9400D3&#x27;, data: [20, 50, 40, 80, 40, 80, 55, 55, 10], lineTension: 0.2, pointStyle: &#x27;rectRounded&#x27;, pointHoverBackgroundColor: &#x27;#FFFFFF&#x27; &#125;] &#125;, options: &#123; legend: &#123; labels: &#123; fontColor: &#x27;#9400D3&#x27;, &lt;!--数据颜色--&gt; fontSize: 12, FontFamily: &#x27;&#x27; &#125; &#125;, layout: &#123; padding: &#123; &lt;!--上下左右填充--&gt; left: 0, right: 0, top: 0, bottom: 0 &#125; &#125;, responsive: true, title: &#123; display: true, text: &#x27;My dataset&#x27; &#125;, scale: &#123; angleLines: &#123; display: true &#125;, ticks: &#123; suggestedMin: 0, &lt;!--最小值--&gt; suggestedMax: 80 &lt;!--最大值--&gt; &#125; &#125; &#125;&#125;&#123;% endchart %&#125;","categories":[],"tags":[]},{"title":"SPI通讯协议","slug":"SPI通讯协议","date":"2021-10-08T23:36:57.000Z","updated":"2021-11-05T14:56:09.851Z","comments":true,"path":"2021/10/09/spi_tong_xun_xie_yi/spi_tong_xun_xie_yi/","link":"","permalink":"https://hp-l.gitee.io/2021/10/09/spi_tong_xun_xie_yi/spi_tong_xun_xie_yi/","excerpt":"","text":"显示屏 TFT-LCD 信号接口有 SPI、MCU、RGB、LVDS、MIPI、eDP、HDMI 等等多种类型。其中就包括 SPI 协议，SPI 协议还有其他用途，FLASHRAM、网络控制器、LCD 显示驱动器、A/D 转换器和MCU等。 SPI 协议通信原理需要至少 3 根线，分别是 SDI（数据输入）、SDO（数据输出）、SCLK（时钟）、CS（片选） SDI – SerialData In,串行数据输入 SDO – SerialDataOut,串行数据输出 SCLK – Serial Clock,时钟信号，由主设备产生 CS – Chip Select,从设备使能信号，由主设备控制 CS是从芯片是否被主芯片选中的控制信号，也就是说只有片选信号为预先规定的使能信号时（高电位或低电位），主芯片对此从芯片的操作才有效。这就使在同一条总线上连接多个 SPI 设备成为可能。 SPI 接口SPI 接口是在 CPU 和外围低速器件之间进行同步串行数据传输，在主器件的移位脉冲下，数据按位传输，高位在前，低位在后，为全双工通信，数据传输速度总体来说比I2C总线要快，速度可达到几 Mbps。 特点：信号线少，协议简单，相对数据速率高。 MOSI – 主器件数据输出，从器件数据输入 MISO – 主器件数据输入，从器件数据输出 SCLK –时钟信号，由主器件产生,最大为 fPCLK/2，从模式频率最大为 fCPU/2 NSS – 从器件使能信号，由主器件控制,有的 IC 会标注为 CS(Chip select) #未完待续#","categories":[],"tags":[{"name":"SPI","slug":"SPI","permalink":"https://hp-l.gitee.io/tags/SPI/"},{"name":"tags2","slug":"tags2","permalink":"https://hp-l.gitee.io/tags/tags2/"},{"name":"tags3","slug":"tags3","permalink":"https://hp-l.gitee.io/tags/tags3/"}]},{"title":"为VScode添加背景","slug":"为VScode添加背景","date":"2021-06-27T12:52:43.000Z","updated":"2021-11-05T14:56:10.340Z","comments":true,"path":"2021/06/27/wei_vscode_tian_jia_bei_jing/wei_vscode_tian_jia_bei_jing/","link":"","permalink":"https://hp-l.gitee.io/2021/06/27/wei_vscode_tian_jia_bei_jing/wei_vscode_tian_jia_bei_jing/","excerpt":"","text":"原生的vscode无背景，没有理想的好看 那如何为VScode添加自己喜欢的壁纸呢？ 打开VScode文件所在位置，我的安装路径是C:\\Users\\用户名\\AppData\\Local\\Programs\\Microsoft VS Code\\再依次打开目录\\resources\\app\\out\\vs\\workbench完整路径是: C:\\Users\\用户名\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\out\\vs\\workbench打开文件workbench.desktop.main.css 添加如下代码 12345678910111213body &#123; /*背景图片的路径*/ background-image: url(C:/Users/用户名/123.jpg); /* 图片不重复 */ background-repeat: no-repeat; /* 图片位置 */ background-position: center; /* 图片大小 */ background-size: cover; /* 透明度 */ opacity: 0.7; /* opacity: 0.75; */&#125; Ctrl + S保存，重启VScode即可，效果如下。 可能会提示Code可能损坏，这个可以忽略，选择不再提示就可以了。","categories":[],"tags":[{"name":"Vscode","slug":"Vscode","permalink":"https://hp-l.gitee.io/tags/Vscode/"},{"name":"美化","slug":"美化","permalink":"https://hp-l.gitee.io/tags/%E7%BE%8E%E5%8C%96/"},{"name":"DIY","slug":"DIY","permalink":"https://hp-l.gitee.io/tags/DIY/"}]},{"title":"DS18B20测温芯片驱动代码","slug":"DS18B20测温芯片","date":"2021-06-02T01:23:02.000Z","updated":"2021-11-05T14:56:09.517Z","comments":true,"path":"2021/06/02/ds18b20_ce_wen_xin_pian/ds18b20_ce_wen_xin_pian_qu_dong_dai_ma/","link":"","permalink":"https://hp-l.gitee.io/2021/06/02/ds18b20_ce_wen_xin_pian/ds18b20_ce_wen_xin_pian_qu_dong_dai_ma/","excerpt":"","text":"以下代码在STC15W408AS单片机进行测试，后面还有自制的PCB的原理图和layout设计（因某些原因需要制作这样一块显示温度的小项目，又想节约成本，于是画的十分简陋……） DS18B20驱动代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &quot;stc15.h&quot; //此处应修改为相应的单片机库sbit DQ = P1^1; //此处为连接DS18B20的引脚号//单总线延时函数void Delay_OneWire(unsigned int t) //STC89C52RC&#123; unsigned char i; while(t--) &#123; for(i=0;i&lt;12;i++); &#125;&#125;//通过单总线向DS18B20写一个字节void Write_DS18B20(unsigned char dat)&#123; unsigned char i; for(i=0;i&lt;8;i++) &#123; DQ = 0; DQ = dat&amp;0x01; Delay_OneWire(5); DQ = 1; dat &gt;&gt;= 1; &#125; Delay_OneWire(5);&#125;//从DS18B20读取一个字节unsigned char Read_DS18B20(void)&#123; unsigned char i; unsigned char dat; for(i=0;i&lt;8;i++) &#123; DQ = 0; dat &gt;&gt;= 1; DQ = 1; if(DQ) &#123; dat |= 0x80; &#125; Delay_OneWire(5); &#125; return dat;&#125;//DS18B20设备初始化bit init_ds18b20(void)&#123; bit initflag = 0; DQ = 1; Delay_OneWire(12); DQ = 0; Delay_OneWire(80); DQ = 1; Delay_OneWire(10); initflag = DQ; Delay_OneWire(5); return initflag;&#125; unsigned char rd_temperature(void)&#123; unsigned char low,high; char temp; init_ds18b20(); Write_DS18B20(0xCC); Write_DS18B20(0x44); //启动温度转换 Delay_OneWire(200); init_ds18b20(); Write_DS18B20(0xCC); Write_DS18B20(0xBE); //读取寄存器 low = Read_DS18B20(); //低字节 high = Read_DS18B20(); //高字节 temp = high&lt;&lt;4; temp |= (low&gt;&gt;4); return temp;&#125; PCB文件及其示意图PCB文件以压缩包形式打包。戳我下载注：我画的是拼板，右侧的那块可能地线没有接到一起。 PCB原件布局 BOM表 Comment Description Footprint Quantity 5261AS 二位共阴数码管 5261AS 1 LED 发光二极管 0603 1 Header 4 Header, 4-Pin HDR1X4 1 Res 10K 0603 1 Res 5.1R 0603 1 STC15W408AS C51单片机 SOP-16 1 DS18B20模组 DS18B20模组 DS18B20模组 1 DS18B20模组相关文件由淘宝商家提供，以下是淘宝商家公开的百度网盘连接。https://pan.baidu.com/s/19CwH6CAaWgVBMKmCA28ygQ 提取码：lggj 单片机代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209#include &quot;stc15.h&quot;#include &quot;intrins.h&quot;#include &quot;onewire.h&quot;#include &quot;absacc.h&quot;#define uchar unsigned char#define uint unsigned intsbit LED = P3 ^ 2; //H有效sbit DIGITAL_a = P1 ^ 2;sbit DIGITAL_b = P1 ^ 3;sbit DIGITAL_c = P1 ^ 4;sbit DIGITAL_d = P1 ^ 5;sbit DIGITAL_e = P5 ^ 4; //sbit DIGITAL_e = P2 ^ 4;sbit DIGITAL_f = P5 ^ 5; //sbit DIGITAL_e = P2 ^ 5;sbit DIGITAL_g = P1 ^ 0;sbit DIGITAL_dp = P3 ^ 7;sbit DIGITAL_H = P3 ^ 6;sbit DIGITAL_L = P3 ^ 3;//sbit DQ = P1 ^ 1;bit temper_flag = 0; //温度读取标志int temp = 0;int intr = 0;/*数码管显示数字*/void printf_num(num)&#123; if (num == 0) &#123; DIGITAL_a = 1; DIGITAL_b = 1; DIGITAL_c = 1; DIGITAL_d = 1; DIGITAL_e = 1; DIGITAL_f = 1; DIGITAL_g = 0; DIGITAL_dp = 0; &#125; /*显示1*/ if (num == 1) &#123; DIGITAL_a = 0; DIGITAL_b = 1; DIGITAL_c = 1; DIGITAL_d = 0; DIGITAL_e = 0; DIGITAL_f = 0; DIGITAL_g = 0; DIGITAL_dp = 0; &#125; /*显示2*/ if (num == 2) &#123; DIGITAL_a = 1; DIGITAL_b = 1; DIGITAL_c = 0; DIGITAL_d = 1; DIGITAL_e = 1; DIGITAL_f = 0; DIGITAL_g = 1; DIGITAL_dp = 0; &#125; /*显示3*/ if (num == 3) &#123; DIGITAL_a = 1; DIGITAL_b = 1; DIGITAL_c = 1; DIGITAL_d = 1; DIGITAL_e = 0; DIGITAL_f = 0; DIGITAL_g = 1; DIGITAL_dp = 0; &#125; /*显示4*/ if (num == 4) &#123; DIGITAL_a = 0; DIGITAL_b = 1; DIGITAL_c = 1; DIGITAL_d = 0; DIGITAL_e = 0; DIGITAL_f = 1; DIGITAL_g = 1; DIGITAL_dp = 0; &#125; /*显示0*/ if (num == 5) &#123; DIGITAL_a = 1; DIGITAL_b = 0; DIGITAL_c = 1; DIGITAL_d = 1; DIGITAL_e = 0; DIGITAL_f = 1; DIGITAL_g = 1; DIGITAL_dp = 0; &#125; /*显示6*/ if (num == 6) &#123; DIGITAL_a = 1; DIGITAL_b = 0; DIGITAL_c = 1; DIGITAL_d = 1; DIGITAL_e = 1; DIGITAL_f = 1; DIGITAL_g = 1; DIGITAL_dp = 0; &#125; /*显示7*/ if (num == 7) &#123; DIGITAL_a = 1; DIGITAL_b = 1; DIGITAL_c = 1; DIGITAL_d = 0; DIGITAL_e = 0; DIGITAL_f = 0; DIGITAL_g = 0; DIGITAL_dp = 0; &#125; /*显示8*/ if (num == 8) &#123; DIGITAL_a = 1; DIGITAL_b = 1; DIGITAL_c = 1; DIGITAL_d = 1; DIGITAL_e = 1; DIGITAL_f = 1; DIGITAL_g = 1; DIGITAL_dp = 0; &#125; /*显示9*/ if (num == 9) &#123; DIGITAL_a = 1; DIGITAL_b = 1; DIGITAL_c = 1; DIGITAL_d = 1; DIGITAL_e = 0; DIGITAL_f = 1; DIGITAL_g = 1; DIGITAL_dp = 0; &#125;&#125;/*数码管显示温度*/void printf_wendu(num)&#123; // printf_num(num/10); DIGITAL_H = 0; printf_num(num / 10); // DIGITAL_H = 0; DIGITAL_H = 1; DIGITAL_a = 0; DIGITAL_b = 0; DIGITAL_c = 0; DIGITAL_d = 0; DIGITAL_e = 0; DIGITAL_f = 0; DIGITAL_g = 0; DIGITAL_dp = 0; // Delay_printf_wendu(); // printf_num(num%10); DIGITAL_L = 0; printf_num(num % 10); // DIGITAL_L = 0; DIGITAL_L = 1; DIGITAL_a = 0; DIGITAL_b = 0; DIGITAL_c = 0; DIGITAL_d = 0; DIGITAL_e = 0; DIGITAL_f = 0; DIGITAL_g = 0; DIGITAL_dp = 0; // Delay_printf_wendu();&#125;void main(void)&#123; float temperature; while (1) &#123; if (temper_flag) &#123; temper_flag = 0; temperature = rd_temperature(); //读温度 temp = temperature; &#125; printf_wendu(temp); intr++; if (intr == 100) //1ms执行一次 &#123; intr = 0; temper_flag = 1; //100ms温度读取标志位置1 &#125; &#125;&#125;","categories":[],"tags":[{"name":"DS18B20","slug":"DS18B20","permalink":"https://hp-l.gitee.io/tags/DS18B20/"}]},{"title":"为Valine评论添加QQ头像识别","slug":"为Valine评论添加QQ头像识别","date":"2021-04-26T06:06:28.000Z","updated":"2021-11-05T14:56:10.512Z","comments":true,"path":"2021/04/26/wei_valine_ping_lun_tian_jia_qq_tou_xiang_shi_bie/wei_valine_ping_lun_tian_jia_qq_tou_xiang_shi_bie/","link":"","permalink":"https://hp-l.gitee.io/2021/04/26/wei_valine_ping_lun_tian_jia_qq_tou_xiang_shi_bie/wei_valine_ping_lun_tian_jia_qq_tou_xiang_shi_bie/","excerpt":"","text":"ValineF12 查看源码 在主题文件夹查询 Valine.js 文件，如果没有 Valine 可以去这里复制下载link 打开文件 Valine.js，Ctrl + F查询img class=&quot;vimg&quot;，注意绿色框的代码，等下要修改的部分。 查到后修改 123&#x27;&lt;img class=&quot;vimg&quot; src=&quot;&#x27; + (T.cdn + (0, s.default)(t.get(&quot;mail&quot;)) + T.params) + &#x27;&quot;&gt;&#x27;; 修改为 1&#x27;&lt;img class=&quot;vimg&quot; src=&quot;&#x27; + qq_img + &#x27;&quot;&gt;&#x27;; 要添加的代码 1234567891011//var qq_img = m.cdn + a(e.get(&quot;mail&quot;)) + m.params;var qq_img = T.cdn + (0, s.default)(t.get(&quot;mail&quot;)) + T.params;if (t.get(&quot;mail&quot;).indexOf(&quot;@qq.com&quot;) &gt;= 0) &#123; var prefix = t.get(&quot;mail&quot;).replace(/@.*/, &quot;&quot;);//前缀 var pattern = /^\\d+$/g; //正则表达式 var result = prefix.match(pattern);//match 是匹配的意思 if (result !== null) &#123; qq_img = &quot;//q1.qlogo.cn/g?b=qq&amp;nk=&quot; + prefix + &quot;&amp;s=100&quot;; &#125;&#125; 修改流程流程： 默认还是gravator头像接口 判断是否是qq邮箱，提取前缀prefix qq头像接口是qq号，如正则筛选剔除–重命名了带英文的qq邮箱 拼接头像地址 加入src显示！ 参考博客链接：https://blog.csdn.net/cungudafa/article/details/104638730","categories":[],"tags":[{"name":"valine","slug":"valine","permalink":"https://hp-l.gitee.io/tags/valine/"}]},{"title":"在material主题使用BBtalk","slug":"在material主题使用BBtalk","date":"2021-04-24T18:13:09.000Z","updated":"2021-11-05T14:56:10.622Z","comments":true,"path":"2021/04/25/zai_material_zhu_ti_shi_yong_bbtalk/zai_material_zhu_ti_shi_yong_bbtalk/","link":"","permalink":"https://hp-l.gitee.io/2021/04/25/zai_material_zhu_ti_shi_yong_bbtalk/zai_material_zhu_ti_shi_yong_bbtalk/","excerpt":"","text":"新建BBtalk页面终端输入hexo new page bb 打开BBtalk文档 复制CDN引用下方的代码 1234567891011&lt;!-- 存放哔哔的容器 --&gt;&lt;div id=&quot;bbtalk&quot;&gt;&lt;/div&gt;&lt;!-- 引用 bbtalk --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/bbtalk@0.1.5/dist/bbtalk.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;bbtalk.init(&#123; appId: &quot;Y5IDwC47czJFXXXXXXSlU44Y-MdYXbMMI&quot;, appKey: &quot;qgrJ3nRwXXXXXXwwnVfj0uaQ&quot;, serverURLs: &#x27;https://AppID前八位.api.lncldglobal.com&#x27;&#125;)&lt;/script&gt; 终端输入hexo s效果如下,圆点位置会有偏差： 打开下方链接，复制js内容，在本地新建一个bbtalk.min.js。 https://hp-l.gitee.io/phone/bb/bbtalk.min.js 再将上文中的复制的CDN引用下方的代码 https://cdn.jsdelivr.net/npm/bbtalk@0.1.5/dist/bbtalk.min.js 改成 ./bbtalk.min.js 即 123456789101112&lt;!-- 存放哔哔的容器 --&gt;&lt;div id=&quot;bbtalk&quot;&gt;&lt;/div&gt;&lt;!-- 引用 bbtalk --&gt;&lt;script src=&quot;./bbtalk.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;bbtalk.init(&#123; appId: &quot;Y5IDwC47czJFXXXXXXSlU44Y-MdYXbMMI&quot;, appKey: &quot;qgrJ3nRwXXXXXXwwnVfj0uaQ&quot;, serverURLs: &#x27;https://AppID前八位.api.lncldglobal.com&#x27;&#125;)&lt;/script&gt; 效果如下，还需进一步调整。","categories":[],"tags":[{"name":"material","slug":"material","permalink":"https://hp-l.gitee.io/tags/material/"},{"name":"BBtalk","slug":"BBtalk","permalink":"https://hp-l.gitee.io/tags/BBtalk/"}]},{"title":"STM32点亮LED","slug":"STM32点亮LED","date":"2021-01-31T12:46:09.000Z","updated":"2021-11-05T14:56:10.072Z","comments":true,"path":"2021/01/31/stm32_dian_liang_led/stm32_dian_liang_led/","link":"","permalink":"https://hp-l.gitee.io/2021/01/31/stm32_dian_liang_led/stm32_dian_liang_led/","excerpt":"","text":"点灯就相当于 python 的print(&quot;hello world&quot;) 定义引脚打开工程文件后，找到相应的引脚，单击选择GPIO_Output，再右键选择 Enter User Label，输入定义的名称。 点击生成代码 点灯代码如下 123//点灯代码 LED1闪烁 HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin); HAL_Delay(300); 自动生成代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041int main(void)&#123; /* USER CODE BEGIN 1 */ /* USER CODE END 1 */ /* MCU Configuration--------------------------------------------------------*/ /* Reset of all peripherals, Initializes the Flash interface and the Systick. */ HAL_Init(); /* USER CODE BEGIN Init */ /* USER CODE END Init */ /* Configure the system clock */ SystemClock_Config(); /* USER CODE BEGIN SysInit */ /* USER CODE END SysInit */ /* Initialize all configured peripherals */ MX_GPIO_Init(); /* USER CODE BEGIN 2 */ /* USER CODE END 2 */ /* Infinite loop */ /* USER CODE BEGIN WHILE */ while (1) &#123; /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ //点灯代码 LED1闪烁 HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin); HAL_Delay(300); &#125; /* USER CODE END 3 */&#125; 连接开发板后点击RUN图标 RUN successfully","categories":[],"tags":[{"name":"STM32","slug":"STM32","permalink":"https://hp-l.gitee.io/tags/STM32/"}]},{"title":"小程序局域网控制ESP32（物联网芯片）","slug":"小程序控制ESP32","date":"2020-12-16T14:57:10.000Z","updated":"2021-11-05T14:56:10.796Z","comments":true,"path":"2020/12/16/xiao_cheng_xu_kong_zhi_esp32/xiao_cheng_xu_ju_yu_wang_kong_zhi_esp32_wu_lian_wang_xin_pian/","link":"","permalink":"https://hp-l.gitee.io/2020/12/16/xiao_cheng_xu_kong_zhi_esp32/xiao_cheng_xu_ju_yu_wang_kong_zhi_esp32_wu_lian_wang_xin_pian/","excerpt":"","text":"微信小程序 体验版二维码。线上版二维码。 线上版二维码 https://gitee.com/HP-L/esp32_-we-char_-connect ESP32 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138from machine import Timer,Pin,RTC #调用GPIO口调用定时器库import socketfrom emp_wifi import Wifiimport timeimport esp32import usocket# from machine import Pin, SPI, UART,I2C# 爬虫使用库import socket,re,sys,osimport urequests as requesthea = &#123;&#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.118 Safari/537.36&#x27;&#125;rtc = RTC()port = 10000 #端口号listenSocket = None #套接字import networkwifi = network.WLAN(network.STA_IF)wifi.active(True)A = Pin(17, Pin.OUT, value=0)B = Pin(12, Pin.OUT, value=1)C = Pin(14, Pin.OUT, value=1)D = Pin(27, Pin.OUT, value=1)E = Pin(26, Pin.OUT, value=1)F = Pin(25, Pin.OUT, value=1)G = Pin(33, Pin.OUT, value=1)# 爬时间def get_time_pa(): time_api_url = &quot;&quot;&quot;http://quan.suning.com/getSysTime.do&quot;&quot;&quot; r = request.get(time_api_url, headers = hea) content = r.text print(&#x27;爬取时间...&#x27;) time = re.search( r&#x27;&#123;&quot;sysTime2&quot;:&quot;(.*?)-(.*?)-(.*?) (.*?):(.*?):(.*?)&quot;,&quot;sysTime1&quot;:&quot;&#x27;, content ) print(r.text[13:29]) print(int(r.text[27:29])) print(int(r.text[23:26])) mm = int(r.text[27:29])# 分钟 hh = int(r.text[23:26])# 小时 rtc = RTC() time_date = rtc.datetime() print(&#x27;重置时间！&#x27;) rtc.datetime((time_date[0], time_date[1], time_date[2], time_date[3], hh, mm, time_date[6], time_date[7])) rtc.datetime()#自动联网def wifi_connect(): wifi_led=Pin(12,Pin.OUT) # 板载指示灯初始化 MODE1左边 wlan = network.WLAN(network.STA_IF) # 以工作站 (wlan) 模式运行，需要创建一个工作站Wi-Fi接口的实例 wlan.active(True) # 在工作站对象上调用激活方法并以True作为输入值传递来激活网络接口 start_time=time.time() # 记录开始时间 if not wlan.isconnected(): # 如果尚未联网成功 print(&quot;当前无线未联网，正在连接中....&quot;)# wlan.connect(&quot;WiFi名称&quot;, &quot;密码&quot;) # 无线网SSID、密码，开始联网 wlan.connect(&#x27;&#x27;,&#x27;&#x27;) # 无线网SSID、密码，开始联网 while not wlan.isconnected(): # 如果还未连接成功，则LED灯闪烁提示 wifi_led.value(1) time.sleep_ms(1000) wifi_led.value(1) time.sleep_ms(1000) print(&quot;正在尝试连接到wifi....&quot;) print(time.time()) if time.time()-start_time&gt;15: # 如果超过15秒还不行，就退出 print(&quot;连接失败!!!无线网连接超过15秒，请检查无线网名称和密码是否正确..&quot;) break if wlan.isconnected(): # 如果联接成功 wifi_led.value(1) # LED灯常亮 IP_info=wlan.ifconfig() print(&quot;##################################################&quot;) print(&quot;无线网已经连接，信息如下：&quot;) print(&quot;IP地址：&quot;+IP_info[0]) print(&quot;子网掩码：&quot;+IP_info[1]) print(&quot;网关：&quot;+IP_info[2]) print(&quot;DNS：&quot;+IP_info[3]) print(&quot;##################################################&quot;) get_time_pa()# 获取芯片温度# def wendu():# f = esp32.raw_temperature()# c = (f-32)/1.8# print(c)# oled.text(&quot;IC:&quot; + str(int(c)),20,0)# 远程连接传输命令函数def connect_to_phone(): try: ip = Wifi.ifconfig()[0][0] #获取IP地址 s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) #设置套接字 sockaddr = socket.getaddrinfo(ip, port) print(sockaddr[0][4]) s.bind(sockaddr[0][4]) print (&#x27;tcp waiting...&#x27;) while True: data, addr = s.recvfrom(1024) print(&#x27;From %s %s&#x27; % addr) print(&#x27;data is %s&#x27; % data) data_utf8 = bytes.decode(data) print(data_utf8) if data_utf8 == &quot;led_1_on&quot;: B.value(0) if data_utf8 == &quot;led_2_on&quot;: C.value(0) if data_utf8 == &quot;led_1_off&quot;: B.value(1) if data_utf8 == &quot;led_2_off&quot;: C.value(1) if data_utf8 == &quot;led_3_on&quot;: D.value(0) if data_utf8 == &quot;led_4_on&quot;: E.value(0) if data_utf8 == &quot;led_3_off&quot;: D.value(1) if data_utf8 == &quot;led_4_off&quot;: E.value(1) if data_utf8 == &quot;led_5_on&quot;: F.value(0) if data_utf8 == &quot;led_6_on&quot;: G.value(0) if data_utf8 == &quot;led_5_off&quot;: F.value(1) if data_utf8 == &quot;led_6_off&quot;: G.value(1) except: if(listenSocket): #判断套接字是否为空 listenSocket.close() #关闭套接字wifi_connect()connect_to_phone() 本程序可连接 OLED1306 也可不连接 OLED1306，不会因为未连接显示屏报错。可直接将 OLED1306 与 ESP32 连接，若不显示，原因可能是接线不稳，接触不良。注意：本程序使用的时 I2C 通讯！！！硬件连接时，I2C必须接上高电平，下面程序是方便面包板使用者使用的程序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250from machine import Timer,Pin,RTC #调用GPIO口调用定时器库import socketfrom emp_wifi import Wifiimport timeimport esp32import usocket# 爬虫使用库import socket,re,sys,osimport urequests as request# 显示屏使用库import machine, ssd1306, gfxhea = &#123;&#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.118 Safari/537.36&#x27;&#125;rtc = RTC()port = 10000 #端口号listenSocket = None #套接字import networkWIFI = Pin(17, Pin.OUT, value=0)LED_1 = Pin(12, Pin.OUT, value=1)LED_2 = Pin(14, Pin.OUT, value=1)LED_3 = Pin(27, Pin.OUT, value=1)LED_4 = Pin(26, Pin.OUT, value=1)LED_5 = Pin(25, Pin.OUT, value=1)LED_6 = Pin(33, Pin.OUT, value=1)LED_7 = Pin(32, Pin.OUT, value=1)L3 = Pin(13, Pin.OUT, value=1)# 爬时间def get_time_pa(): time_api_url = &quot;&quot;&quot;http://quan.suning.com/getSysTime.do&quot;&quot;&quot; r = request.get(time_api_url, headers = hea) content = r.text print(&#x27;爬取时间...&#x27;) time = re.search( r&#x27;&#123;&quot;sysTime2&quot;:&quot;(.*?)-(.*?)-(.*?) (.*?):(.*?):(.*?)&quot;,&quot;sysTime1&quot;:&quot;&#x27;, content ) print(r.text[13:29]) print(int(r.text[27:29])) print(int(r.text[23:26])) mm = int(r.text[27:29])# 分钟 hh = int(r.text[23:26])# 小时 rtc = RTC() time_date = rtc.datetime() print(&#x27;重置时间！&#x27;) rtc.datetime((time_date[0], time_date[1], time_date[2], time_date[3], hh, mm, time_date[6], time_date[7])) rtc.datetime()#自动联网def wifi_connect(): wifi_led=Pin(23,Pin.OUT) # 板载指示灯初始化 MODE1左边 wlan = network.WLAN(network.STA_IF) # 以工作站 (wlan) 模式运行，需要创建一个工作站Wi-Fi接口的实例 wlan.active(True) # 在工作站对象上调用激活方法并以True作为输入值传递来激活网络接口 start_time=time.time() # 记录开始时间 if not wlan.isconnected(): # 如果尚未联网成功 print(&quot;当前无线未联网，正在连接中....&quot;) wlan.connect(&#x27;***&#x27;,&#x27;***&#x27;) # 无线网SSID、密码，开始联网 while not wlan.isconnected(): # 如果还未连接成功，则LED灯闪烁提示 wifi_led.value(0) time.sleep_ms(1000) wifi_led.value(0) time.sleep_ms(1000) print(&quot;正在尝试连接到wifi....&quot;) print(time.time()) if time.time()-start_time&gt;15: # 如果超过15秒还不行，就退出 print(&quot;连接失败!!!无线网连接超过15秒，请检查无线网名称和密码是否正确..&quot;) break if wlan.isconnected(): # 如果联接成功 wifi_led.value(0) # LED灯常亮 IP_info=wlan.ifconfig() print(&quot;##################################################&quot;) print(&quot;无线网已经连接，信息如下：&quot;) print(&quot;IP地址：&quot;+IP_info[0]) print(&quot;子网掩码：&quot;+IP_info[1]) print(&quot;网关：&quot;+IP_info[2]) print(&quot;DNS：&quot;+IP_info[3]) print(&quot;##################################################&quot;)# get_time_pa()oled_str1=&#x27;&#x27;oled_str2=&#x27;&#x27;oled_str3=&#x27;&#x27;oled_str4=&#x27;&#x27;oled_str5=&#x27;&#x27;def oled_process(str1,ip,oled,graphics):# i2c = machine.I2C(scl=machine.Pin(18), sda=machine.Pin(19))# oled = ssd1306.SSD1306_I2C(128 ,64 ,i2c)# graphics = gfx.GFX(128, 64, oled.pixel) global oled_str1 global oled_str2 global oled_str3 global oled_str4 global oled_str5 oled_str1=oled_str2 oled_str2=oled_str3 oled_str3=oled_str4 oled_str4=oled_str5 oled_str5=str1 oled.fill(0) graphics._slow_vline(0, 0, 64, 1) graphics._slow_vline(127, 0, 128, 1) graphics._slow_hline(0, 15, 128, 1) graphics._slow_hline(0, 16, 128, 1) graphics._slow_hline(0, 0, 128, 1) graphics._slow_hline(0, 63, 128, 1) oled.text(&quot;port:10000 &amp; ip&quot;,0+2,0) oled.text(ip,0+2,8) oled.text(oled_str5,0+2,16+2) oled.text(oled_str4,0+2,24+2) oled.text(oled_str3,0+2,32+2) oled.text(oled_str2,0+2,40+2) oled.text(oled_str1,0+2,48+2) oled.show()# 显示屏代码def oled_try(): try: i2c = machine.I2C(scl=machine.Pin(18), sda=machine.Pin(19)) oled = ssd1306.SSD1306_I2C(128 ,64 ,i2c) graphics = gfx.GFX(128, 64, oled.pixel) print(&quot;get&quot;) connect_to_phone_oled(oled,graphics) except: print(&quot;false&quot;) connect_to_phone()# 获取芯片温度# def wendu():# f = esp32.raw_temperature()# c = (f-32)/1.8# print(c)# oled.text(&quot;IC:&quot; + str(int(c)),20,0)def connect_to_phone_oled(oled,graphics): try: ip = Wifi.ifconfig()[0][0] #获取IP地址 s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) #设置套接字 sockaddr = socket.getaddrinfo(ip, port) print(sockaddr[0][4]) s.bind(sockaddr[0][4]) oled_process(sockaddr[0][4][0],sockaddr[0][4][0],oled,graphics) print(&quot;oled&quot;) print(&#x27;tcp waiting...&#x27;) while True: data, addr = s.recvfrom(1024) print(&#x27;From %s %s&#x27; % addr) print(&#x27;data is %s&#x27; % data) data_utf8 = bytes.decode(data) oled_process(data_utf8,sockaddr[0][4][0],oled,graphics) data_size = s.sendto(data, addr) # print(&#x27;From %s %s&#x27; % data_utf8) # print(&#x27;data is %s&#x27; % data_utf8) if data_utf8 == &quot;led_1_on&quot;: LED_1.value(0)# data_size = s.sendto(&quot;led_1_on&quot;, addr) if data_utf8 == &quot;led_2_on&quot;: LED_2.value(0) if data_utf8 == &quot;led_1_off&quot;: LED_1.value(1)# data_size = s.sendto(&quot;led_1_off&quot;, addr) if data_utf8 == &quot;led_2_off&quot;: LED_2.value(1) if data_utf8 == &quot;led_3_on&quot;: LED_3.value(0) if data_utf8 == &quot;led_4_on&quot;: LED_4.value(0) if data_utf8 == &quot;led_3_off&quot;: LED_3.value(1) if data_utf8 == &quot;led_4_off&quot;: LED_4.value(1) if data_utf8 == &quot;led_5_on&quot;: LED_5.value(0) if data_utf8 == &quot;led_6_on&quot;: LED_6.value(0) if data_utf8 == &quot;led_5_off&quot;: LED_5.value(1) if data_utf8 == &quot;led_6_off&quot;: LED_6.value(1) if data_utf8 == &quot;led_7_on&quot;: LED_7.value(1) if data_utf8 == &quot;led_7_off&quot;: LED_7.value(1) except: if(listenSocket): #判断套接字是否为空 listenSocket.close() #关闭套接字def connect_to_phone(): try: ip = Wifi.ifconfig()[0][0] #获取IP地址 s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) #设置套接字 sockaddr = socket.getaddrinfo(ip, port) print(sockaddr[0][4]) s.bind(sockaddr[0][4]) print (&#x27;tcp waiting...&#x27;) while True: data, addr = s.recvfrom(1024) print(&#x27;From %s %s&#x27; % addr) print(&#x27;data is %s&#x27; % data) data_utf8 = bytes.decode(data)# print(&#x27;From %s %s&#x27; % data_utf8)# print(&#x27;data is %s&#x27; % data_utf8) data_size = s.sendto(data, addr) if data_utf8 == &quot;led_1_on&quot;: LED_1.value(0) if data_utf8 == &quot;led_2_on&quot;: LED_2.value(0) if data_utf8 == &quot;led_1_off&quot;: LED_1.value(1) if data_utf8 == &quot;led_2_off&quot;: LED_2.value(1) if data_utf8 == &quot;led_3_on&quot;: LED_3.value(0) if data_utf8 == &quot;led_4_on&quot;: LED_4.value(0) if data_utf8 == &quot;led_3_off&quot;: LED_3.value(1) if data_utf8 == &quot;led_4_off&quot;: LED_4.value(1) if data_utf8 == &quot;led_5_on&quot;: LED_5.value(0) if data_utf8 == &quot;led_6_on&quot;: LED_6.value(0) if data_utf8 == &quot;led_5_off&quot;: LED_5.value(1) if data_utf8 == &quot;led_6_off&quot;: LED_6.value(1) if data_utf8 == &quot;led_7_on&quot;: LED_7.value(1) if data_utf8 == &quot;led_7_off&quot;: LED_7.value(1) except: if(listenSocket): #判断套接字是否为空 listenSocket.close() #关闭套接字wifi_connect()oled_try() 测试视屏","categories":[],"tags":[{"name":"ESP32","slug":"ESP32","permalink":"https://hp-l.gitee.io/tags/ESP32/"},{"name":"物联网","slug":"物联网","permalink":"https://hp-l.gitee.io/tags/%E7%89%A9%E8%81%94%E7%BD%91/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://hp-l.gitee.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"微信小程序学习笔记","slug":"微信小程序_1","date":"2020-12-11T17:39:40.000Z","updated":"2021-11-05T14:56:10.858Z","comments":true,"path":"2020/12/12/wei_xin_xiao_cheng_xu_1/wei_xin_xiao_cheng_xu_xue_xi_bi_ji/","link":"","permalink":"https://hp-l.gitee.io/2020/12/12/wei_xin_xiao_cheng_xu_1/wei_xin_xiao_cheng_xu_xue_xi_bi_ji/","excerpt":"","text":"开发文档链接微信官方文档 文件全局文件： app.js 全局 js 文件：js 代码全局可以调用 app.json 全局配置文件：导航栏，背景颜色，标题，窗口配置 app.wxss 全局样式文件：统一样式 utils 文件夹：封装自定义的工具 pages 小程序页面文件夹：所有的页面都在该文件夹下管理，pages 文件夹中，一个文件夹代表一个页面。 局部文件：一个页面的文件 wxml wxss js json app.json123456789101112&#123; &quot;pages&quot;: [&quot;pages/index/index&quot;, &quot;pages/logs/logs&quot;], //页面管理 &quot;window&quot;: &#123; //窗口界面 &quot;backgroundTextStyle&quot;: &quot;light&quot;, &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;, //导航栏颜色 &quot;navigationBarTitleText&quot;: &quot;Weixin&quot;, &quot;navigationBarTextStyle&quot;: &quot;black&quot; &#125;, &quot;style&quot;: &quot;v2&quot;, &quot;sitemapLocation&quot;: &quot;sitemap.json&quot;&#125; 若要添加页面或者直接在&quot;pages&quot;: [&quot;pages/index/index&quot;, &quot;pages/logs/logs&quot;]中添加，IDE 会直接生成一个文件夹及内部页面文件。 若在全局配置中窗口界面配置了&quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;的同时，在单个页面(例如 logo 页面)的配置文件也配置了&quot;navigationBarBackgroundColor&quot;: &quot;#000&quot;，这是只有当跳转到(例如 logo 页面)时，导航栏颜色才会变成#000。 微信小程序中的 js变量js 变量：用于储存信息的容器声明时使用 var+变量名，变量类型通过赋值来决定注意：变量必须一字母开头，也可以$和_开头，大小写敏感 12345678var answer = &quot;It&#x27;s alright&quot;;var x1 = 43.0;var x = true;var cars = new Array();cars[0] = &quot;Saab&quot;;var cars = [&quot;saab&quot;, &quot;Volor&quot;];var person = null; //清空变量内容var carname; //执行后内容为undefined 对象12345var person = &#123; firstname: &quot;John&quot;, lastname: &quot;Doe&quot;, id: 5566,&#125;; 对象寻址方式 12name = person.lastname;name = person[&quot;lastname&quot;]; 运算+,-,*,/,%比较运算符，返回值均为FALSE&amp;TRUE 逻辑运算符&amp;&amp;,||,！ 123456y = 5;z = 2;x = y + z;txt1 = &quot;what a very&quot;;txt2 = &quot;nice day&quot;;txt3 = txt1 + txt2; //此时txt3 = &quot;what a verynice day&quot; 条件if1234567891011121314151617if (condition) &#123; //当condition为true时，才执行下面语句&#125;if (condition) &#123; //当condition为true时，才执行下面语句&#125; else &#123; //否则执行下面代码&#125;if (condition) &#123; //当condition为true时，才执行下面语句&#125; else if (condition1) &#123; //否则执行下面代码&#125; else &#123; //否则执行下面代码&#125; 循环for12345678for (语句1; 语句2; 语句3) &#123; //被执行的代码，语法和C语言相似&#125;var x = 0;for (var i = 0; i &lt; 5; i++) &#123; x = x + 1;&#125; 小程序中自动生成的 js 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// pages/index/index.jsPage(&#123; /** * 页面的初始数据 */ data: &#123;&#125;, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) &#123;&#125;, /** * 生命周期函数--监听页面初次渲染完成 */ onReady: function () &#123;&#125;, /** * 生命周期函数--监听页面显示 */ onShow: function () &#123;&#125;, /** * 生命周期函数--监听页面隐藏 */ onHide: function () &#123;&#125;, /** * 生命周期函数--监听页面卸载 */ onUnload: function () &#123;&#125;, /** * 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh: function () &#123;&#125;, /** * 页面上拉触底事件的处理函数 */ onReachBottom: function () &#123;&#125;, /** * 用户点击右上角分享 */ onShareAppMessage: function () &#123;&#125;,&#125;); page123Page(&#123; //页面内容，不写任何东西也不会报错&#125;); data 和函数data 对象 1234data:&#123; msg:&#x27;hello!&#x27;, flag:false&#125; function 函数 123function(参数)&#123; //函数内容&#125;, 小程序的生命周期和回掉函数12345678加载 |渲染 |显示----&gt;隐藏 | | | |卸载&lt;----隐藏 当程序运行到各个生命周期函数的节点时，会执行生命周期回调函数 回掉函数： onLoad() 页面加载时触发 onShow() 页面显示/切入前台触发 onReady() 页面初次渲染完成时触发运行完上面流程即进入激活状态 onShow() 页面显示/切入前台触发 onHide() 页面影藏/切入后台触发 onUnload() 页面卸载时触发 onPullDownRefresh() 下拉刷新 onReachBottom()上拉触底事件 onShareAppMessage() 转发按钮，自定义转发内容 事件响应事件：视图层到逻辑层的通讯方式，将用户的行为反馈到逻辑层即事件可以通过在 wxml 中绑定在组件上，达到触发条件时，会触发相应的事件处理函数(事件响应)对象可以额外携带如 id,dataset 等额外信息 组建事件响应： 组件上绑定事件处理函数点击事件绑定处理函数的方法：使用bindtap属性，属性值为 js 中的事件的事件处理函数的函数名 123&lt;view id=&quot;tapTest&quot; data-hi=&quot;WeChat&quot; bindtab=&quot;tapName&quot;&gt; Click me!&lt;/view&gt; Page 中写相应函数处理事件，单数是 event，函数名要和 wxml 中绑定的 bindtap 属性属性值一致 12345Page(&#123; tapName(event) &#123; console.log(event); //该语句将获取到的数据打印在了编译器的窗口中 &#125;,&#125;); 小程序 js 数据处理 this 关键字this：当前对象的一个引用，在使用时往往指向的是上一层对象，在函数中执行时指向的是全局对象 访问页面数据：this.data 页面初始数据的那部分调用页面内的函数：this.onload() 执行这一语句就会执行 onload()函数 tips: 若在 API 中使用 this，需要在调用 API 前暂存指向页面的 this，例 1var that = this; 调用方法 1234567891011121314151617Page(&#123; data:&#123; a:1, b:&#x27;balabala&#x27;, c:[&quot;a&quot;,&quot;b&quot;,] &#125;, action:function()&#123; this.data.a=666 console.log(&quot;这是新的函数&quot;) &#125;, onLoad: function(options)&#123; console.log(this.data)//调时窗口打印出data中的所有值 this.action()//调用action函数 &#125;&#125;) 页面数据更新123456this.setData(&#123; //变量名：新的值， //变量名：新的值， //变量名：新的值 a: 8888,&#125;); 不同页面的数据出传递方法有二，其一，页面跳转过程中携带参数。其二，将数据存于全局数据中，各个页面在从全局中读取 第二种用法：在 app.js 中 123456App(&#123; globalData: &#123; //globalData可以改成其他名称 userInfo: null, &#125;,&#125;); 各个页面与全局数据进行交互，使用getApp()历程如下: 页面的 js 文件如下 1234onLoad:function(options)&#123; console.log(getApp().globalData.abc) getApp().globalData.abc = 456&#125; app.js 文件中含有如下 12345678App(&#123; globalData: &#123; //globalData可以改成其他名称 userInfo: null, abc: 1234, d: [], &#125;,&#125;); 微信小程序的 API 介绍API 的类型： 事件监听 API：以 on 开头用于监听 同步 API：以 Sync 结尾的 API 都是同步 API，起执行结果可通过函数返回值直接获取。当执行到 API 时，停止组件进程等待 API 执行完。 异步 API：都接受一个 object 类型的参数。程序会启动一个分支来运行 API API 内容 success 部分：接口调用成功的回调函数 fail 部分：接口调用失败的回调函数 complete 部分：接口调用结束的回调函数 微信登陆 API 123456789101112wx.login(&#123; success(res) &#123; //成功执行 &#125;, fail(res) &#123; console.log(res.errMsg); //失败执行 &#125;, complete(res) &#123; //一定执行 &#125;,&#125;); Object 类型参数包含的字段 属性 类型 说明 errMsg string 错误信息，若成功为 errCode number 错误码，成功时为 0 其他 Any 接口返回数据 调用 API 进行页面互交 消息提示框 12345wx.showToast(&#123; title: &quot;成功&quot;, //文字 icon: &quot;success&quot;, //对勾 duration: 2000, //延时时间&#125;); 模态弹窗 1234567891011wx.showModal(&#123; title: &quot;提示&quot;, content: &quot;这是一个模态弹窗&quot;, success(res) &#123; if (res.confirm) &#123; console.log(&quot;用户点击确定&quot;); &#125; else if (res.cancel) &#123; console.log(&quot;用户点击取消&quot;); &#125; &#125;,&#125;); Loading 提示框 1234567wx.showLoading(&#123; title: &quot;加载中&quot;,&#125;);setTimeout(function () &#123; wx.hideLoading(); //必须调用hideLoading才能关闭loading&#125;, 2000); 页面路由 API wx.relaunch()关闭所有页面，打开到指定页面 wx.redirectTo()关闭当前页面，跳转到指定页面 wx.navigateTo()保留当前页面，跳转到指定页面 wx.navigateBack()关闭当前页面，返回上一级或多级页面 123456789101112131415wx.relaunch(&#123; url: &quot;/pages/jsjs/jsjs&quot;,&#125;);wx.redirectTo(&#123; url: &quot;../jsjs/jsjs&quot;,&#125;);wx.navigateTo(&#123; url: &quot;/pages/jsjs/jsjs&quot;,&#125;);wx.navigateBack(&#123; delta: 1,&#125;);","categories":[],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://hp-l.gitee.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"ESP32_物联网那些事","slug":"ESP32-物联网那些事","date":"2020-12-03T07:44:23.000Z","updated":"2021-11-05T14:56:09.797Z","comments":true,"path":"2020/12/03/esp32_wu_lian_wang_na_xie_shi/esp32_wu_lian_wang_na_xie_shi/","link":"","permalink":"https://hp-l.gitee.io/2020/12/03/esp32_wu_lian_wang_na_xie_shi/esp32_wu_lian_wang_na_xie_shi/","excerpt":"","text":"ESP32_物联网那些事通过查阅资料，ESP32 是一款物联网模块，它支持 TCP/IP 协议，于是我们可以使用 socket 通讯，实现局域网通信，它也支持 MQTT 通讯，呵远程连接到阿里云。下面的链接有详细的使用说明。 Socket 通信 使用物联网第一步：烧录固件这里提到的固件是micropython官方出的固件，我在网上还看到了不少通过C语言写.bin固件的教程，可以写自己需要的固件刷入到ESP32中 可以参考这篇文章 ESP32_micropython固件烧录 如何连接到 WiFi？Micropython联网同步时间 ESP32 是可以使用 REPL 的，REPL 就像局域网下的 VSCode，可以在浏览器上编写程序，可惜他不能开机自启，于是就有人开发了一款叫做 EMP 的 IDE ，下面有链接。 EMP项目简介 我在执行原文提供的代码时发现set_boot_mode()报错 原文提供的代码 123456789101112&gt;&gt;&gt; from emp_boot import set_boot_mode&gt;&gt;&gt; set_boot_mode()&gt;&gt;&gt; from emp_boot import set_boot_mode&gt;&gt;&gt; set_boot_mode()[0] Boot with nothing attention: this option will clear up boot.py, careful![1] Boot with wifi startup this mode will auto start wifi connect program.[2] Easy to develop this mode is for developers.In this mode you can develop much easier via EMP- IDE(emp.1zlab.com)Please input your choice [0-2]: 下面给出解决方案： 在 ESP32 的 boot.py 中所有代码替换成如下代码： 1234567891011121314151617181920from emp_wifi import Wififrom emp_webrepl import WebREPLfrom emp_utils import webrepl_passfrom emp_utils import post_ipfrom machine import Pin # 引用LED使用import timewifi_LED = Pin(12, Pin.OUT, value=1) #定义LEDif __name__ == &#x27;__main__&#x27;: Wifi.connect() post_ip(Wifi.ifconfig()[0][0]) wifi_LED.value(0) time.sleep(0.5) wifi_LED.value(1)# WebREPL.start(password=webrepl_pass())# from emp_ide import *&#x27;&#x27;&#x27;上面两行是调用emp_ide，取消注释就可以使用emp_ide，这里注释掉的原因是想直接调用连接WiFi的函数不使用emp_ide&#x27;&#x27;&#x27; 在按复位即可，终端中会提示连接网络并且输入密码，连接过的 WiFi 会被记住，下次连接自动连，非常方便 利用 ESP32 联网实现一些小功能我们可以通过 socket 通讯使得 PC 可以传输数据流到 ESP32 中，下面是代码，这里仿照的是Socket 通信文末的代码，原文中代码只能传输字节，下面代码可以传输中文字符，通过定义 IO 口可以实现局域网点亮 LED，甚至舵机。 ESP32 TCP 服务端12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from machine import Timer,Pin,RTC #调用GPIO口调用定时器库import socketfrom emp_wifi import Wifiimport networkwifi = network.WLAN(network.STA_IF)wifi.active(True)# 远程连接传输命令函数def connect_to_phone(): try: # 注意：线连接到WiFi网络！ # 如果未连接到网络，以下是连接到网络的代码 # Wifi.connect() ip = Wifi.ifconfig()[0][0] #获取IP地址 listenSocket = socket.socket() #创建套接字 listenSocket.bind((ip, port)) #绑定地址和端口号 listenSocket.listen(1) #监听套接字, 最多允许一个连接 listenSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) #设置套接字 print (&#x27;tcp waiting...&#x27;) while True: print(&quot;accepting.....&quot;) conn, addr = listenSocket.accept() #接收连接请求，返回收发数据的套接字对象和客户端地址 print(addr, &quot;connected&quot;) while True: data = conn.recv(1024) #接收数据（1024字节大小） if(len(data) == 0): #判断客户端是否断开连接 print(&quot;close socket&quot;) conn.close() #关闭套接字 break # print(data) code_utf8 = bytes.decode(data) print(code_utf8) ret = conn.send(data) #发送数据 if code_utf8 == &quot;led1 open&quot;: B.value(0) if code_utf8 == &quot;led2 open&quot;: C.value(0) if code_utf8 == &quot;led1 down&quot;: B.value(1) if code_utf8 == &quot;led2 down&quot;: C.value(1) except: if(listenSocket): #判断套接字是否为空 listenSocket.close() #关闭套接字wifi_connect() PC 端123456789101112131415# -*- coding: UTF-8 -*-# PC TCP Clientimport socket # 导入 socket 模块s = socket.socket() # 创建 socket 对象host = &#x27;192.168.2.231&#x27; # esp32 ipport = 10000 # 设置端口号s.connect((host, port))if __name__ == &#x27;__main__&#x27;: while True: msg = raw_input(&#x27;&gt;&gt;&gt; &#x27;) s.send(msg)","categories":[],"tags":[{"name":"ESP32","slug":"ESP32","permalink":"https://hp-l.gitee.io/tags/ESP32/"},{"name":"物联网","slug":"物联网","permalink":"https://hp-l.gitee.io/tags/%E7%89%A9%E8%81%94%E7%BD%91/"}]},{"title":"STM32开发环境搭建","slug":"STM32开发环境搭建","date":"2020-11-25T05:36:00.000Z","updated":"2021-11-05T14:56:09.863Z","comments":true,"path":"2020/11/25/stm32_kai_fa_huan_jing_da_jian/stm32_kai_fa_huan_jing_da_jian/","link":"","permalink":"https://hp-l.gitee.io/2020/11/25/stm32_kai_fa_huan_jing_da_jian/stm32_kai_fa_huan_jing_da_jian/","excerpt":"","text":"准备工作Integrated Development Environment for STM32 汉化和安装主题请参考下面的链接https://blog.csdn.net/wct3344142/article/details/104142863 我使用的网址是 1http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;eclipse&#x2F;technology&#x2F;babel&#x2F;update-site&#x2F;R0.18.1&#x2F;2019-12&#x2F; 选项和上面的链接里的不一样thonny_download.png 新建工程流程如图(点开查看大图)","categories":[],"tags":[{"name":"STM32","slug":"STM32","permalink":"https://hp-l.gitee.io/tags/STM32/"}]},{"title":"搭建Arduino_ESP2866环境","slug":"搭建Arduino-ESP2866环境","date":"2020-11-21T00:03:45.000Z","updated":"2021-11-05T14:56:11.039Z","comments":true,"path":"2020/11/21/da_jian_arduino_esp2866_huan_jing/da_jian_arduino_esp2866_huan_jing/","link":"","permalink":"https://hp-l.gitee.io/2020/11/21/da_jian_arduino_esp2866_huan_jing/da_jian_arduino_esp2866_huan_jing/","excerpt":"","text":"下载 Arduino IDE Arduino 官网 Arduino IDE 1.8.13 下载完成后打开 arduino.exe 添加 json 文件打开首选项在开发板管理器网址填入 1https:&#x2F;&#x2F;arduino.esp8266.com&#x2F;stable&#x2F;package_esp8266com_index.json 或者 1http:&#x2F;&#x2F;wechat.doit.am&#x2F;package_esp8266com_index.json 在GitHub 上的项目里有最新的版本，但是需要科学上网所以选择第二个 添加 ESP8266 开发板搜索栏键入 8266如果出现下载失败可以从这里下载 如果安装过其他版本的 esp8266sdk，请先删除，再使用本安装包。 解压完成后，再打开 Arduino IDE，即可在 菜单栏&gt;工具&gt;开发板 中找到你使用的 esp8266 开发板。 来自 Arduino 中文社区的大佬 https://share.weiyun.com/5CGEKJO 安装完成后重启 Arduino IDE 就会有显示了","categories":[],"tags":[{"name":"Arduino","slug":"Arduino","permalink":"https://hp-l.gitee.io/tags/Arduino/"},{"name":"ESP2866","slug":"ESP2866","permalink":"https://hp-l.gitee.io/tags/ESP2866/"}]},{"title":"手机定时切换壁纸","slug":"手机定时切换壁纸","date":"2020-11-15T04:47:40.000Z","updated":"2021-11-05T14:56:10.883Z","comments":true,"path":"2020/11/15/shou_ji_ding_shi_qie_huan_bi_zhi/shou_ji_ding_shi_qie_huan_bi_zhi/","link":"","permalink":"https://hp-l.gitee.io/2020/11/15/shou_ji_ding_shi_qie_huan_bi_zhi/shou_ji_ding_shi_qie_huan_bi_zhi/","excerpt":"","text":"准备 手机安装 termuxAPP 和 termux_API (这里给出参考博客链接) 国光的 Termux 高级终端安装使用配置教程 跳转下载链接 API 下载链接 完成基础的安装 12pkg install termux-api #termux-APIpkg install cronie #linux 定时软件 编辑定时运行的 shell 脚本编辑 bizhi.sh 文件 123456#!/bin/bashtermux-wallpaper -f ./壁纸所在目录/$((RANDOM%152+1)).jpg# $((RANDOM%152+1))是用来随机取数的# $((RANDOM%152+1))可以换成文件名 编辑定时任务文件终端输入 1crontab -e 再输入 12# 每隔五分钟执行一次bizhi.sh文件*&#x2F;5 * * * * .&#x2F;文件路径&#x2F;bizhi.sh 应为 Termux 默认不启动 crontab，所以进入 Termux 要开启一下 1crond start #开启 在手机设置中，termux 和 termux-API 都开启手动管理","categories":[],"tags":[{"name":"termux","slug":"termux","permalink":"https://hp-l.gitee.io/tags/termux/"}]},{"title":"Micropython联网同步时间","slug":"micropython联网同步时间","date":"2020-11-08T23:41:14.000Z","updated":"2021-11-05T14:56:10.246Z","comments":true,"path":"2020/11/09/micropython_lian_wang_tong_bu_shi_jian/micropython_lian_wang_tong_bu_shi_jian/","link":"","permalink":"https://hp-l.gitee.io/2020/11/09/micropython_lian_wang_tong_bu_shi_jian/micropython_lian_wang_tong_bu_shi_jian/","excerpt":"","text":"ntp 服务器可以自己选择，可以使用爬虫爬去时间也可以用 NTP 服务器同步，将 wifi_connect()函数最后一行 get_time_py 换成 get_time()即可直接上程序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788# This file is executed on every boot (including wake-boot from deepsleep)#import esp#esp.osdebug(None)#import webrepl#webrepl.start()#使用ESP32上的MicroPython連接Wi-Fi網絡from machine import Pin,RTCimport network #網絡模塊import time #計時器模塊import ntptime #ntptime網絡時間協議模塊#自动联网def wifi_connect(): wifi_led&#x3D;Pin(18,Pin.OUT) # 初始化LED燈，可自定義 wlan &#x3D; network.WLAN(network.STA_IF) # wlan.active(True) # 激活網絡接口 start_time&#x3D;time.time() # 記錄開始時間 if not wlan.isconnected(): # 如若聯網失敗 print(&quot;当前无线未联网，正在连接中....&quot;) # wlan.connect(&quot;此处改为你的无线网名称&quot;, &quot;无线网密码&quot;) wlan.connect(&#39;XXXXXXXX&#39;,&#39;XXXXXXXX&#39;) # 無綫網SSID、密碼 while not wlan.isconnected(): # 如若還未連接成功，LED則會以閃爍的方式提示未連接到WIFI wifi_led.value(0) time.sleep_ms(1000) # 延時函數1000毫秒 wifi_led.value(1) time.sleep_ms(1000) print(&quot;正在尝试连接到wifi....&quot;) print(time.time()) if time.time()-start_time&gt;15: # 如若超過15秒還未連接則退出鏈接 print(&quot;連接失敗!!!請檢查無綫網名稱和密碼是否正確...&quot;) break if wlan.isconnected(): # 如若連接成功 wifi_led.value(1) # LED燈常亮 IP_info&#x3D;wlan.ifconfig() print(&quot;##################################################&quot;) print(&quot;已連接WIFI，信息如下：&quot;) print(&quot;IP地址：&quot;+IP_info[0]) print(&quot;子網掩碼：&quot;+IP_info[1]) print(&quot;網関：&quot;+IP_info[2]) print(&quot;DNS：&quot;+IP_info[3]) print(&quot;##################################################&quot;) get_time_py()#同步時間def get_time(): print(&quot;同步時間&quot;) print() print(&quot;同步前本地時間：%s&quot; %str(time.localtime())) print(&quot;##&quot;) ntptime.NTP_DELTA &#x3D; 3155644800 # 設置 UTC+8偏移時間（秒），不不設置就是UTC0# ntptime.host &#x3D; &#39;pool.ntp.org&#39; # 可選ntp服務器為阿里雲服務器，默認是&quot;pool.ntp.org&quot; ntptime.host &#x3D; &#39;edu.ntp.org.cn&#39;# ntptime.host &#x3D; &#39;210.72.145.44&#39; # 國家授時中心服務器IP地址# ntptime.host &#x3D; &#39;ntp1.aliyun.com&#39;# ntptime.host &#x3D; &#39;cn.ntp.org.cn&#39; ntptime.settime() # 修改設備時間 print(&quot;同步后本地時間：%s&quot; %str(time.localtime())) print(&quot;##################################################&quot;) rtc &#x3D; RTC() print(rtc.datetime())# 爬取時間def get_time_py(): time_api_url &#x3D; &quot;&quot;&quot;http:&#x2F;&#x2F;quan.suning.com&#x2F;getSysTime.do&quot;&quot;&quot; r &#x3D; request.get(time_api_url) content &#x3D; r.text print(&#39;爬取時間...&#39;) time &#x3D; re.search( r&#39;&#123;&quot;sysTime2&quot;:&quot;(.*?)-(.*?)-(.*?) (.*?):(.*?):(.*?)&quot;,&quot;sysTime1&quot;:&quot;&#39;, content ) print(r.text[13:29]) print(int(r.text[27:29])) print(int(r.text[23:26])) mm &#x3D; int(r.text[27:29])# 分鐘 hh &#x3D; int(r.text[23:26])# 小時 rtc &#x3D; RTC() time_date &#x3D; rtc.datetime() print(&#39;重置時間！&#39;) rtc.datetime((time_date[0], time_date[1], time_date[2], time_date[3], hh, mm, time_date[6], time_date[7])) rtc.datetime()#開始執行聯網wifi_connect()","categories":[],"tags":[{"name":"micropython","slug":"micropython","permalink":"https://hp-l.gitee.io/tags/micropython/"}]},{"title":"ESP32_micropython固件烧录","slug":"ESP32-micropython固件烧录","date":"2020-11-05T01:40:23.000Z","updated":"2021-11-05T14:56:09.602Z","comments":true,"path":"2020/11/05/esp32_micropython_gu_jian_shao_lu/esp32_micropython_gu_jian_shao_lu/","link":"","permalink":"https://hp-l.gitee.io/2020/11/05/esp32_micropython_gu_jian_shao_lu/esp32_micropython_gu_jian_shao_lu/","excerpt":"","text":"ESP32_micropython 固件烧录烧录准备1.micropython IDE：Thonny 2.ESP32 的 micropython 固件：戳我进下载页面，micropython 还支持其他芯片link，下载页面有很多固件选择，由于我的是不带 SPIRAM 的，因此我选择了第一个。 3.烧录工具：这里提供两种，esptool 在 GitHub 上有教程，这里就不细讲。 esptool：github link Thonny: micropython IDE Flash 下载工具：link 4.ESP32 模组： 打开淘宝…… 烧录过程使用 Thonny 烧录点击工具栏运行，选择“选择解释器…” 选择我们在 Micropython 官网下载的固件后点击 install这是从 ESP 官网上下载的启动模式方法： 即GPIO0和GPIO2全部接地，同时按下复位按键，保持1毫秒再断开GPIO0断开接地（因为 GPIO0 默认上拉），便开始下载。 使用 Flash 下载工具从官网下载了工具后双击打开，等待几秒后，点击 ESP32downloadTools，选择我们在 Micropython 官网下载的固件后点击 START 再按照上文中的启动方法启动即可下载。 成功之后 shell 会出现下图： 像 python 一样可以实时输入，ESP32 可以直接看到 LED 灯被点亮","categories":[],"tags":[{"name":"ESP32","slug":"ESP32","permalink":"https://hp-l.gitee.io/tags/ESP32/"},{"name":"micropython","slug":"micropython","permalink":"https://hp-l.gitee.io/tags/micropython/"}]}],"categories":[],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"https://hp-l.gitee.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://hp-l.gitee.io/tags/Ubuntu/"},{"name":"SPI","slug":"SPI","permalink":"https://hp-l.gitee.io/tags/SPI/"},{"name":"tags2","slug":"tags2","permalink":"https://hp-l.gitee.io/tags/tags2/"},{"name":"tags3","slug":"tags3","permalink":"https://hp-l.gitee.io/tags/tags3/"},{"name":"Vscode","slug":"Vscode","permalink":"https://hp-l.gitee.io/tags/Vscode/"},{"name":"美化","slug":"美化","permalink":"https://hp-l.gitee.io/tags/%E7%BE%8E%E5%8C%96/"},{"name":"DIY","slug":"DIY","permalink":"https://hp-l.gitee.io/tags/DIY/"},{"name":"DS18B20","slug":"DS18B20","permalink":"https://hp-l.gitee.io/tags/DS18B20/"},{"name":"valine","slug":"valine","permalink":"https://hp-l.gitee.io/tags/valine/"},{"name":"material","slug":"material","permalink":"https://hp-l.gitee.io/tags/material/"},{"name":"BBtalk","slug":"BBtalk","permalink":"https://hp-l.gitee.io/tags/BBtalk/"},{"name":"STM32","slug":"STM32","permalink":"https://hp-l.gitee.io/tags/STM32/"},{"name":"ESP32","slug":"ESP32","permalink":"https://hp-l.gitee.io/tags/ESP32/"},{"name":"物联网","slug":"物联网","permalink":"https://hp-l.gitee.io/tags/%E7%89%A9%E8%81%94%E7%BD%91/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://hp-l.gitee.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"Arduino","slug":"Arduino","permalink":"https://hp-l.gitee.io/tags/Arduino/"},{"name":"ESP2866","slug":"ESP2866","permalink":"https://hp-l.gitee.io/tags/ESP2866/"},{"name":"termux","slug":"termux","permalink":"https://hp-l.gitee.io/tags/termux/"},{"name":"micropython","slug":"micropython","permalink":"https://hp-l.gitee.io/tags/micropython/"}]}